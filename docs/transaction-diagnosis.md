# 분산 트랜잭션 처리 전략

## 개요

서비스 확장에 따라 애플리케이션 서버와 DB를 도메인별로 분리했을 때 발생하는 트랜잭션 처리의 한계와 대응 방안을 정리한 문서입니다.

## 1. 분산 환경에서의 트랜잭션 한계

### 1.1 분산 트랜잭션의 복잡성

**문제점:**
- 여러 DB에 걸친 ACID 속성 보장이 어려움
- 2PC(Two-Phase Commit) 프로토콜의 한계
  - 모든 참여자가 준비 완료될 때까지 대기 (성능 저하)
  - 코디네이터 장애 시 전체 트랜잭션 블로킹
  - 네트워크 파티션 발생 시 처리 불가
- 일부 DB 장애 시 전체 트랜잭션 롤백 어려움

**예시:**
```
주문 서비스 DB    재고 서비스 DB    결제 서비스 DB
    |                |                |
    |-- PREPARE ---->|                |
    |                |-- PREPARE ---->|
    |<--- READY -----|                |
    |                |<--- READY -----|
    |-- COMMIT ----->|                |
    |                |-- COMMIT ----->|
    (만약 이 시점에 네트워크 장애 발생 시?)
```

### 1.2 데이터 일관성 문제

**문제점:**
- 강한 일관성(Strong Consistency) 보장 불가능
- 부분 실패(Partial Failure) 시 데이터 불일치 발생
- 트랜잭션 경계가 서비스 단위로 제한됨
- 분산 환경에서는 CAP 정리에 따라 일관성과 가용성 사이의 트레이드오프 발생

**시나리오 예시:**
```
1. 주문 서비스: 주문 생성 성공 O
2. 재고 서비스: 재고 차감 성공 O
3. 결제 서비스: 결제 실패 X

→ 주문은 생성되었지만 결제는 안 됨
→ 재고는 차감되었지만 실제 판매는 안 됨
```

### 1.3 성능 이슈

**문제점:**
- 서비스 간 네트워크 통신 오버헤드 증가
- 분산 락(Distributed Lock) 사용 시 레이턴시 상승
- 동기식 호출 시 응답 시간 누적
- 타임아웃 관리 복잡도 증가


## 2. 대응 방안

### 2.1 Saga 패턴

긴 수명 트랜잭션을 여러 개의 짧은 트랜잭션으로 나누고, 각 트랜잭션은 독립적으로 커밋되며, 실패 시 이미 완료된 트랜잭션에 대한 보상 트랜잭션을 실행하는 패턴입니다.

**트랜잭션 흐름:**
```
정상: T1(주문) → T2(재고) → T3(결제) → 완료
실패: T1 → T2 → T3(실패) → C2(재고복구) → C1(주문취소)
```

**보상 트랜잭션 설계 원칙:**
1. **멱등성(Idempotent)**: 여러 번 실행해도 같은 결과
2. **가역성(Reversible)**: 원래 상태로 되돌릴 수 있어야 함
3. **재시도 가능(Retriable)**: 실패 시 재시도 가능
4. **순서 보장**: 역순으로 실행

#### 2.1.1 Orchestration 방식 (조율 기반)

중앙 조정자(Orchestrator)가 모든 트랜잭션 흐름을 제어하고 관리합니다.

**구조:**
```
            [Saga Orchestrator]
                   |
    +--------------+--------------+
    |              |              |
[주문 서비스]  [재고 서비스]  [결제 서비스]
```

**장점:**
- 트랜잭션 흐름이 명확하고 중앙에서 관리
- 보상 로직 구현이 단순하고 일관성 있음
- 디버깅과 모니터링이 용이
- 조건부 분기나 복잡한 비즈니스 로직 처리 용이
- Saga 상태를 중앙에서 관리하여 복구 가능

**단점:**
- 조정자가 단일 장애점(SPOF)이 될 수 있음
- 조정자에 비즈니스 로직이 집중되어 복잡도 증가
- 서비스 간 결합도가 높아질 수 있음
- 조정자의 성능이 전체 시스템에 영향

**적용 시나리오:**
- 복잡한 비즈니스 규칙이 있는 경우
- 여러 조건 분기가 필요한 경우
- 명확한 트랜잭션 흐름 추적이 중요한 경우

#### 2.1.2 Choreography 방식 (협업 기반)

각 서비스가 이벤트를 구독하고 발행하면서 자율적으로 동작합니다.

**구조:**
```
[주문] --OrderCreated--> [이벤트 버스]
                              |
          +-------------------+-------------------+
          ↓                   ↓                   ↓
      [재고 서비스]       [결제 서비스]       [알림 서비스]
```

**장점:**
- 서비스 간 결합도가 낮음 (이벤트만 의존)
- 중앙 조정자 없이 분산 처리
- 확장성이 좋음 (새 서비스 추가 용이)
- 단일 장애점이 없음
- 각 서비스가 독립적으로 진화 가능

**단점:**
- 전체 트랜잭션 흐름 파악이 어려움
- 순환 의존성 발생 가능
- 디버깅이 복잡함 (분산 추적 필요)
- 트랜잭션 상태 추적이 어려움
- 이벤트 순서 보장이 어려울 수 있음

**적용 시나리오:**
- 서비스 간 독립성이 중요한 경우
- 확장성이 최우선인 경우
- 이벤트 기반 아키텍처를 사용 중인 경우

#### 2.1.3 두 방식의 비교

| 구분 | Orchestration | Choreography |
|------|--------------|--------------|
| **제어 방식** | 중앙 집중식 | 분산 자율식 |
| **결합도** | 높음 | 낮음 |
| **복잡도** | 조정자에 집중 | 전체 시스템에 분산 |
| **가시성** | 높음 | 낮음 (분산 추적 필요) |
| **확장성** | 조정자가 병목 가능 | 높음 |
| **장애 처리** | 중앙 관리 | 각 서비스 처리 |


### 2.2 이벤트 소싱 + CQRS

모든 상태 변경을 이벤트로 저장하고, Command와 Query를 분리하는 패턴입니다.

**장점:**
- 완전한 감사 추적(Audit Trail)
- 이벤트 재생으로 상태 복구 가능
- 시점별 상태 조회 가능
- 읽기와 쓰기 성능을 독립적으로 최적화

**단점:**
- 구현 복잡도가 높음
- 이벤트 스키마 관리 필요
- 학습 곡선이 가파름


### 2.3 Outbox 패턴

로컬 트랜잭션과 메시지 발행의 원자성을 보장하는 패턴입니다.\n
DB 반영 시 메시지 발행에 대해 DB에 저장하고, outbox processor가 outbox 테이블을 체크해서 메시지 발행 작업을 처리하는 방식입니다. 

**장점:**
- 메시지 손실 없고 재시도 가능
- 트랜잭션 일관성 보장 (outbox 이벤트 메세지가 같은 로컬 트랜잭션 내에 커밋되기 때문에)

**단점:**
- 추가 인프라 부담
- 메시지 중복 발생 가능 (멱등성 처리 필요)
- Outbox 테이블 관리 필요


### 2.4 최종 일관성 + 재시도/보상

즉시 일관성 대신 최종적으로 일관성을 보장하는 방식입니다.

**구현 전략:**
- 멱등성 키를 사용한 중복 방지
- 지수 백오프(Exponential Backoff) 재시도
- Circuit Breaker로 장애 격리
- Dead Letter Queue로 실패 메시지 처리


### 2.5 읽기 전용 복제본 활용

Command와 Query를 분리하여 성능과 확장성을 개선합니다.


## 3. 실무 적용 가이드

### 3.1 단계별 마이그레이션 전략

**1단계: 모놀리스 유지, 읽기 분리**
```
[Application] → [Master DB]
              ↘ [Replica DB] (읽기 전용)
```

**2단계: 중요하지 않은 도메인 분리**
```
[Order Service] → [Order DB]
[Product Service] → [Product DB] (분리)
```

**3단계: 핵심 도메인 분리 + Saga 패턴 적용**
```
[Order Service] → [Order DB]
[Inventory Service] → [Inventory DB]
[Payment Service] → [Payment DB]
      ↑
[Saga Orchestrator]
```

### 3.2 패턴 선택 가이드

| 상황 | 추천 패턴 | 이유 |
|------|----------|------|
| 트랜잭션 흐름이 복잡하고 중앙 제어 필요 | Saga (Orchestration) | 명확한 흐름 관리, 디버깅 용이 |
| 서비스 간 결합도를 최소화하고 싶음 | Saga (Choreography) | 느슨한 결합, 확장성 |
| 완전한 감사 추적이 필요함 | Event Sourcing | 모든 변경 이력 보존 |
| 메시지 발행 신뢰성이 중요함 | Outbox 패턴 | At-least-once 보장 |
| 빠른 구현이 필요함 | 최종 일관성 + 재시도 | 구현 단순, 비교적 쉬움 |


## 4. CAP 정리와 트레이드오프

분산 시스템에서는 다음 세 가지 중 두 가지만 선택 가능합니다.

- **C (Consistency)**: 일관성 - 모든 노드가 같은 시점에 같은 데이터를 봄
- **A (Availability)**: 가용성 - 모든 요청이 응답을 받음
- **P (Partition Tolerance)**: 분할 내성 - 네트워크 분할에도 시스템 동작

**선택 전략:**
- **금융, 결제**: CP 선택 (일관성 우선)
- **소셜 미디어, 추천**: AP 선택 (가용성 우선)
- **E-commerce**: 도메인별 선택
  - 재고/결제: CP
  - 상품 조회: AP